(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{459:function(t,a,s){"use strict";s.r(a);var v=s(20),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"center-container"},[s("p",[s("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://i.loli.net/2020/10/15/IVszDyFvqk7AlmZ.png",loading:"lazy"}})])]),t._v(" "),s("h2",{attrs:{id:"定义aop术语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义aop术语"}},[t._v("#")]),t._v(" 定义AOP术语")]),t._v(" "),s("p",[t._v("描述切面的常用术语有"),s("strong",[t._v("通知（advice）、切点（pointcut）和连接点（join point）")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"通知-advice"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通知-advice"}},[t._v("#")]),t._v(" 通知(Advice)")]),t._v(" "),s("p",[t._v("在AOP术语中，"),s("strong",[t._v("切面的工作被称为通知")]),t._v("。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？")]),t._v(" "),s("p",[t._v("Spring切面可以应用5种类型的通知：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("前置通知")]),t._v("（Before）：在目标方法被调用之前调用通知功能；")]),t._v(" "),s("li",[s("strong",[t._v("后置通知")]),t._v("（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；")]),t._v(" "),s("li",[s("strong",[t._v("返回通知")]),t._v("（After-returning）：在目标方法成功执行之后调用通知；")]),t._v(" "),s("li",[s("strong",[t._v("异常通知")]),t._v("（After-throwing）：在目标方法抛出异常后调用通知；")]),t._v(" "),s("li",[s("strong",[t._v("环绕通知")]),t._v("（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。")])]),t._v(" "),s("h3",{attrs:{id:"连接点-join-point"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#连接点-join-point"}},[t._v("#")]),t._v(" 连接点(Join point)")]),t._v(" "),s("p",[s("strong",[t._v("连接点是在应用执行过程中能够插入切面的一个点")]),t._v("。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。")]),t._v(" "),s("h3",{attrs:{id:"切点-pointcut"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#切点-pointcut"}},[t._v("#")]),t._v(" 切点(Pointcut)")]),t._v(" "),s("p",[t._v("如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。")]),t._v(" "),s("h3",{attrs:{id:"切面-aspect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#切面-aspect"}},[t._v("#")]),t._v(" 切面(Aspect)")]),t._v(" "),s("p",[s("strong",[t._v("切面是通知和切点的结合")]),t._v("。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。")]),t._v(" "),s("h3",{attrs:{id:"织入-weaving"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#织入-weaving"}},[t._v("#")]),t._v(" 织入(Weaving)")]),t._v(" "),s("p",[t._v("织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("编译期")]),t._v("：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("类加载期")]),t._v("：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving， LTW） 就支持以这种方式织入切面。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("运行期")]),t._v("：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。")])])]),t._v(" "),s("h3",{attrs:{id:"引入-introduction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引入-introduction"}},[t._v("#")]),t._v(" 引入(Introduction)")]),t._v(" "),s("p",[t._v("引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法setLastModified(Date)和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中,从而可以在无需修改这些现有的类的情况下， 让它们具有新的行为和状态。")])])}),[],!1,null,null,null);a.default=r.exports}}]);