(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{457:function(t,e,a){"use strict";a.r(e);var r=a(20),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"reactor简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactor简介"}},[t._v("#")]),t._v(" Reactor简介")]),t._v(" "),a("p",[t._v("Reactor是JVM的完全非阻塞式反应式编程基础，具有高效的需求管理（以管理“背压”的形式）。 它直接与Java 8功能API集成在一起，特别是CompletableFuture，Stream和Duration。 它提供了可组合的异步序列API，例如Flux（用于[N]个元素）和Mono（用于[0 | 1]个元素），并且广泛实现了Reactive Streams规范。")]),t._v(" "),a("p",[t._v("Reactor还支持与Reactor-Netty项目的非阻塞进程间通信。 适用于微服务架构，Reactor Netty为HTTP（包括Websockets），TCP和UDP提供了支持背压的网络引擎。,并且完全支持反应式编码和解码。")]),t._v(" "),a("h2",{attrs:{id:"先决条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先决条件"}},[t._v("#")]),t._v(" 先决条件")]),t._v(" "),a("p",[a("strong",[t._v("Reactor Core在Java 8及更高版本上运行")]),t._v("。")]),t._v(" "),a("p",[t._v("它对"),a("code",[t._v("org.reactivestreams：reactive-streams：1.0.3")]),t._v("具有传递依赖。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("Android支持:")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Reactor 3并未正式支持Android或将其定位为Android（如果强烈要求使用RxJava 2，请考虑使用RxJava 2）。但是，它在Android SDK 26（Android O）及更高版本上应该可以正常工作。")])]),t._v(" "),a("li",[a("p",[t._v("启用反欺骗功能后，它可能会在Android SDK 21（Android 5.0）及更高版本上正常工作。 参见https://developer.android.com/studio/write/java8-support#library-desugaring")])])])]),t._v(" "),a("h2",{attrs:{id:"反应式编程简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#反应式编程简介"}},[t._v("#")]),t._v(" 反应式编程简介")]),t._v(" "),a("p",[t._v("Reactor是反应式编程范例的实现，可以总结如下：")]),t._v(" "),a("blockquote",[a("p",[t._v("反应式编程是一种异步编程范式，它涉及数据流和变化的传播。这意味着可以通过所采用的编程语言轻松表达静态（例如数组）或动态（例如事件发射器）数据流。")])]),t._v(" "),a("p",[t._v("— https://en.wikipedia.org/wiki/Reactive_programming")]),t._v(" "),a("p",[t._v("作为响应式编程方向的第一步，Microsoft在.NET生态系统中创建了响应式扩展（Rx）库。然后RxJava在JVM上实现了反应式编程。随着时间的流逝，通过Reactive Streams的努力，出现了Java的标准化，该规范定义了JVM上的响应库的一组接口和交互规则。它的接口已集成到"),a("code",[t._v("Flow")]),t._v("该类下的Java 9中。")]),t._v(" "),a("p",[t._v("反应式编程范例通常以面向对象的语言表示，作为"),a("strong",[t._v("Observer设计模式")]),t._v("的扩展。您还可\t以将主要的反应流模式与熟悉的Iterator设计模式进行比较，因为所有这些库中的"),a("code",[t._v("Iterable")]),t._v("- "),a("code",[t._v("Iterator")]),t._v("对都有双重性 。一个主要的区别是，虽然"),a("strong",[t._v("Iterator是基于pull")]),t._v("的，但"),a("strong",[t._v("反应式流是基于push")]),t._v("的。")]),t._v(" "),a("p",[t._v("使用迭代器是命令式编程模式，即使访问值的方法仅由负责"),a("code",[t._v("Iterable")]),t._v("。实际上，由开发人员决定何时选择"),a("code",[t._v("next()")]),t._v("序列中的项目。在反应性物流中，上述对的等价物为"),a("code",[t._v("Publisher-Subscriber")]),t._v("。但是，当 "),a("code",[t._v("Publisher")]),t._v("新可用值"),a("em",[t._v("出现时")]),t._v("，正是通知订户，而这一推送方面是做出反应的关键。同样，应用于推入值的操作以声明方式而不是命令方式表示：程序员表示计算的逻辑，而不是描述其确切的控制流程。")]),t._v(" "),a("p",[t._v("除了推送值之外，还以明确定义的方式涵盖了错误处理和完成方面。A "),a("code",[t._v("Publisher")]),t._v("可以"),a("code",[t._v("Subscriber")]),t._v("（通过调用"),a("code",[t._v("onNext")]),t._v("）将新值推入其值，但也可以通过（调用"),a("code",[t._v("onError")]),t._v("）或完成（通过调用"),a("code",[t._v("onComplete")]),t._v("）发出错误信号。错误和完成都会终止序列。可以总结如下：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("onNext x "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("N")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("onError "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" onComplete"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("这种方法非常灵活。该模式支持没有值，一个值或n个值（包括无限个值序列，例如时钟的连续滴答声）用例。")]),t._v(" "),a("h2",{attrs:{id:"从命令式编程到反应式编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从命令式编程到反应式编程"}},[t._v("#")]),t._v(" 从命令式编程到反应式编程")]),t._v(" "),a("p",[t._v("反应性库（例如Reactor）旨在解决JVM上“经典”异步方法的这些缺点，同时还着重于一些其他方面：")]),t._v(" "),a("ul",[a("li",[t._v("可组合性和可读性")]),t._v(" "),a("li",[t._v("以丰富的运算符词汇操纵数据流")]),t._v(" "),a("li",[t._v("订阅之前没有任何反应")]),t._v(" "),a("li",[t._v("背压或消费者向生产者发出排放速率过高信号的能力")]),t._v(" "),a("li",[t._v("并发不可知的高级但高价值的抽象")])])])}),[],!1,null,null,null);e.default=v.exports}}]);