(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{447:function(t,e,r){"use strict";r.r(e);var o=r(19),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"单reactor多线程模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单reactor多线程模型"}},[t._v("#")]),t._v(" 单Reactor多线程模型")]),t._v(" "),r("div",{staticClass:"center-container"},[r("p",[r("img",{attrs:{src:"https://i.loli.net/2020/07/25/ka4xUs5bWhLN9rK.png",alt:""}})])]),r("h3",{attrs:{id:"单reactor多线程模型分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单reactor多线程模型分析"}},[t._v("#")]),t._v(" 单Reactor多线程模型分析")]),t._v(" "),r("ol",[r("li",[t._v("Reactor实例通过select监控客户端请求事件，收到事件请求通过Dispatch进行分发。")]),t._v(" "),r("li",[t._v("如果建立链接请求，则由Acceptor通过accept处理连接请求，然后创建Handler对象处理完成连接后的业务操作。")]),t._v(" "),r("li",[t._v("如果不是连接请求，则由reactor分发调用连接对应的handler来处理。")]),t._v(" "),r("li",[t._v("handler只负责响应事件，不做具体的业务处理，通过read读取数据后，会分发给worker线程池中的某个线程处理业务。")]),t._v(" "),r("li",[t._v("worker线程池会分配独立的线程完成真正的业务，并将结果返回给handler。")]),t._v(" "),r("li",[t._v("handler收到结果后通过send将结果返回给客户端\n"),r("strong",[t._v("优点：")]),t._v("\n可以充分利用多核CPU的处理能力。\n"),r("strong",[t._v("缺点:")]),t._v("\n多线程会数据共享和访问比较复杂，reactor处理了所有的事件的监听和相应，在单线程运行，在高并发场景容易出现性能瓶颈。")])]),t._v(" "),r("h2",{attrs:{id:"主从reactor多线程模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主从reactor多线程模型"}},[t._v("#")]),t._v(" 主从Reactor多线程模型")]),t._v(" "),r("blockquote",[r("p",[t._v("针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下会成为性能瓶颈，则产生的让Reactor运行在多线程中。")])]),t._v(" "),r("div",{staticClass:"center-container"},[r("p",[r("img",{attrs:{src:"https://i.loli.net/2020/07/25/ka4xUs5bWhLN9rK.png",alt:""}})])]),r("h3",{attrs:{id:"主从reactor多线程模型分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主从reactor多线程模型分析"}},[t._v("#")]),t._v(" 主从Reactor多线程模型分析")]),t._v(" "),r("ol",[r("li",[t._v("Reactor主线程MainReactor对象通过select监听链接事件，收到事件请求通过Acceptor处理连接事件。")]),t._v(" "),r("li",[t._v("当Acceptor处理连接事件后，MainReactor将连接分配给subReactor。")]),t._v(" "),r("li",[t._v("subReactor将链接加入链接队列进行监听，并创建handler进行各种事件处理。")]),t._v(" "),r("li",[t._v("有新的事件发生时， subReacto将调用相应的handler处理。")]),t._v(" "),r("li",[t._v("read读取数据后，会分发给worker线程进行业务处理。")]),t._v(" "),r("li",[t._v("worker线程池会分配独立的线程完成真正的业务，并将结果返回r。")]),t._v(" "),r("li",[t._v("handler收到结果后通过send将结果返回给客户端。")])]),t._v(" "),r("p",[t._v("Reactor主线程可以对应多个Reactor子线程，即Reactor主线程可以和Reactor子线程相关联。\n"),r("strong",[t._v("优点：")])]),t._v(" "),r("p",[t._v("父线程与子线程的数据交互简单，职责明确，父线程只需要接收新连接，子线程完成后续的业务处理\n父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据\n"),r("strong",[t._v("缺点：")])]),t._v(" "),r("p",[t._v("编程复制读较高。")]),t._v(" "),r("h2",{attrs:{id:"netty模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty模型"}},[t._v("#")]),t._v(" Netty模型")]),t._v(" "),r("blockquote",[r("p",[t._v("netty 的线程模型并不是一成不变的，它实际取决于用户的启动参数配置。通过设置不同的启动参数，Netty 可以同时支持 Reactor 单线程模型、多线程模型。")])]),t._v(" "),r("h3",{attrs:{id:"简单版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单版"}},[t._v("#")]),t._v(" 简单版")]),t._v(" "),r("blockquote",[r("p",[t._v("Netty主要基于主从Reactor多线程模型做了一定改进")])]),t._v(" "),r("div",{staticClass:"center-container"},[r("p",[r("img",{attrs:{src:"https://i.loli.net/2020/07/25/78NIpGFZglXu6zk.png",alt:""}})])]),r("ol",[r("li",[t._v("BossGrop线程维护Selector，只关注Accept；")]),t._v(" "),r("li",[t._v("当接受到Accept事件，获取对应的SocketChannel，封装成NIOSocketChannel并注册到Work线程（事件循环），并进行维护。")]),t._v(" "),r("li",[t._v("当Worker线程监听到Selector中通道发生自己感兴趣的事件后，进行处理（handler）。")])]),t._v(" "),r("h3",{attrs:{id:"完整版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#完整版"}},[t._v("#")]),t._v(" 完整版")]),t._v(" "),r("div",{staticClass:"center-container"},[r("p",[r("img",{attrs:{src:"https://i.loli.net/2020/07/25/Yp4UDX3VzrGe1gB.png",alt:""}})])]),r("ol",[r("li",[t._v("Netty抽象出两组线程池BossGroup专门负责接受客户端的链接，WorkerGroup专门负责网络的读写。")]),t._v(" "),r("li",[t._v("BossGroup与WorkerGroup都是NioEventLoopGroup")]),t._v(" "),r("li",[t._v("NioEventLoopGroup为事件循环组，组内含有多个事件循环，每个事件循环都是NioEventLoop。")]),t._v(" "),r("li",[t._v("NioEventLoop表示不断循环的执行处理任务的线程，每个NioEventLoop都有一个Selector，用于监听绑定在其上的Socket网络通讯。")]),t._v(" "),r("li",[t._v("NioEventLoopGroup可以有多个线程，含有多个NioEventLoop。")]),t._v(" "),r("li",[t._v("BossNioEventLoop循环执行三步骤：\n"),r("ol",[r("li",[t._v("轮询accept事件")]),t._v(" "),r("li",[t._v("处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker NioEventLoop上的Selector。")]),t._v(" "),r("li",[t._v("处理任务队列的任务，即runAllTasks")])])]),t._v(" "),r("li",[t._v("Worker NioEventLoop循环执行步骤：\n"),r("ol",[r("li",[t._v("轮询read、write事件。")]),t._v(" "),r("li",[t._v("在相应NioSocketChannel的处理I/O事件")]),t._v(" "),r("li",[t._v("处理任务队列的任务，即runAllTasks")])])]),t._v(" "),r("li",[t._v("Worker NioEventLoop在处理数据时会使用Pipline(管道)，Pipline中包含channel。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);