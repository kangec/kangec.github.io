(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{459:function(t,a,e){"use strict";e.r(a);var r=e(19),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。简单来说：索引是数据结构。")]),t._v(" "),e("h2",{attrs:{id:"索引的数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引的数据结构"}},[t._v("#")]),t._v(" 索引的数据结构")]),t._v(" "),e("h2",{attrs:{id:"b-tree索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-tree索引"}},[t._v("#")]),t._v(" B-Tree索引")]),t._v(" "),e("p",[e("strong",[t._v("B-Tree的结构")])]),t._v(" "),e("div",{staticClass:"center-container"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2020/08/18/tyhERxVmQSzHKgT.png",alt:""}})])]),e("blockquote",[e("p",[t._v("B-Tree无论是叶子结点还是非叶子结点，都含有key和一个指向数据的指针，只要找到某个节点后，就可以根据指针找到磁盘地址从而找到数据。")])]),t._v(" "),e("h2",{attrs:{id:"b-tree索引-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-tree索引-2"}},[t._v("#")]),t._v(" B+Tree索引")]),t._v(" "),e("h4",{attrs:{id:"b-tree的结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-tree的结构"}},[t._v("#")]),t._v(" "),e("strong",[t._v("B+Tree的结构")])]),t._v(" "),e("div",{staticClass:"center-container"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2020/08/18/ZW9PA3aKkL142md.png",alt:""}})])]),e("blockquote",[e("p",[t._v("B+Tree所有叶子结点才有指向数据的指针。非叶子结点就是纯索引数据和主键。每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。")])]),t._v(" "),e("p",[t._v("如上图，是一颗b+树，"),e("strong",[t._v("浅蓝色")]),t._v("的块我们称之为一个"),e("strong",[t._v("磁盘块")]),t._v("，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。")]),t._v(" "),e("h4",{attrs:{id:"b-tree的查找过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-tree的查找过程"}},[t._v("#")]),t._v(" B+Tree的查找过程")]),t._v(" "),e("p",[t._v("如图所示，如果要查找数据项29，那么首先会"),e("strong",[t._v("把磁盘块1由磁盘加载到内存")]),t._v("，此时发生一次IO，在内存中"),e("strong",[t._v("用二分查找确定29在17和35之间，锁定磁盘块1的P2指针")]),t._v("，内存时间因为非常短（相比磁盘的IO）可以忽略不计，"),e("strong",[t._v("通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存")]),t._v("，发生第二次IO，"),e("strong",[t._v("29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存")]),t._v("，发生第三次IO，同时"),e("strong",[t._v("内存中做二分查找找到29，结束查询")]),t._v("，总计三次IO。真实的情况是，"),e("strong",[t._v("3层的b+树可以表示上百万的数据")]),t._v("，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。")]),t._v(" "),e("h4",{attrs:{id:"b-tree树性质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-tree树性质"}},[t._v("#")]),t._v(" B+Tree树性质")]),t._v(" "),e("p",[t._v("1.通过上面的分析，"),e("strong",[t._v("我们知道IO次数取决于b+数的高度h")]),t._v("，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有"),e("strong",[t._v("h=log(m+1)N")]),t._v("，当数据量"),e("strong",[t._v("N一定的情况下，m越大，h越小")]),t._v("；而"),e("strong",[t._v("m = 磁盘块的大小 / 数据项的大小")]),t._v("，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。")]),t._v(" "),e("p",[t._v("2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，"),e("strong",[t._v("b+数是按照从左到右的顺序来建立搜索树的")]),t._v("，比如当(张三,20,F)这样的数据来检索的时候，"),e("strong",[t._v("b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据")]),t._v("；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。")]),t._v(" "),e("blockquote",[e("p",[t._v("参考文章： "),e("a",{attrs:{href:"https://tech.meituan.com/2014/06/30/mysql-index.html"}},[t._v("MySQL索引原理")])])]),t._v(" "),e("h2",{attrs:{id:"非聚集索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非聚集索引"}},[t._v("#")]),t._v(" 非聚集索引")]),t._v(" "),e("p",[t._v("非聚集索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中。")]),t._v(" "),e("h3",{attrs:{id:"myisam的索引实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#myisam的索引实现"}},[t._v("#")]),t._v(" MyISAM的索引实现")]),t._v(" "),e("p",[t._v("MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。以下为MyISAM原理图：")]),t._v(" "),e("div",{staticClass:"center-container"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2020/08/18/jQEa5zMA8fVkXvC.png",alt:""}})])]),e("p",[t._v("MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：")]),t._v(" "),e("div",{staticClass:"center-container"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2020/08/18/OqXQZSk4gPc3DaC.png",alt:""}})])]),e("p",[t._v("同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。")]),t._v(" "),e("h2",{attrs:{id:"聚集索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引"}},[t._v("#")]),t._v(" 聚集索引")]),t._v(" "),e("p",[t._v("聚集索引指主索引文件和数据文件为同一份文件，聚集索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引。聚集索引保证关键字的值相近的元组存储的物理位置也相近（所以字符串类型不宜建立聚集索引，特别是随机字符串，会使得系统进行大量的移动操作）。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("聚集索引结构：节点页只包含了索引列，叶子页包含了行的全部数据。聚集索引“就是表”，因此可以不需要独立的行存储。")])]),t._v(" "),e("h3",{attrs:{id:"innodb的聚集索引实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#innodb的聚集索引实现"}},[t._v("#")]),t._v(" "),e("strong",[t._v("InnoDB的聚集索引实现")])]),t._v(" "),e("ol",[e("li",[t._v("InnoDB对主键建立聚集索引。")]),t._v(" "),e("li",[t._v("如果不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。")]),t._v(" "),e("li",[t._v("如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚集索引。")])]),t._v(" "),e("p",[t._v("与MyISAM索引实现不同的是"),e("strong",[t._v("InnoDB的数据文件本身就是索引文件")]),t._v("。从上文知道，"),e("strong",[t._v("MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址")]),t._v("。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。")]),t._v(" "),e("div",{staticClass:"center-container"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2020/08/18/eiTNtHashCYD5zu.png",alt:""}})])]),e("p",[t._v("如图所示，叶节点包含了完整的数据记录。这种索引因此被称为聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。")]),t._v(" "),e("p",[t._v("其次，"),e("strong",[t._v("与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址")]),t._v("。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：")]),t._v(" "),e("div",{staticClass:"center-container"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2020/08/18/PUAaXNiuHdD2hBj.png",alt:""}})])]),e("p",[t._v("这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。")]),t._v(" "),e("p",[t._v("了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白"),e("strong",[t._v("为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大")]),t._v("。再例如，"),e("strong",[t._v("用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择")]),t._v("。")]),t._v(" "),e("blockquote",[e("p",[t._v("参考文章：《高性能MySQL》 "),e("a",{attrs:{href:"http://blog.codinglabs.org/articles/theory-of-mysql-index.html"}},[t._v("《MySQL索引背后的数据结构及算法原理》")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);