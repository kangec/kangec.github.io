(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{481:function(s,a,n){"use strict";n.r(a);var t=n(20),v=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[s._v("几乎所有的排序都有两个基本的操作：")]),s._v(" "),n("ol",[n("li",[s._v("关键字大小的比较。")]),s._v(" "),n("li",[s._v("改变记录的位置。具体处理方式依赖于记录的存储形式，对于顺序型记录，一般移动记录本身，而链式\n存储的记录则通过改变指向记录的指针实现重定位。")])]),s._v(" "),n("h2",{attrs:{id:"插入排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#插入排序"}},[s._v("#")]),s._v(" 插入排序")]),s._v(" "),n("p",[s._v("插入排序类型算法有直接插入排序和希尔排序，它们的基本思想是：每次将一个待排序的记录，按其"),n("strong",[s._v("关键字大小插入到前面已经排好序的记录集中")]),s._v("，使记录依然有序，直到所有待排序记录全部插入完成。")]),s._v(" "),n("h3",{attrs:{id:"直接插入排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#直接插入排序"}},[s._v("#")]),s._v(" 直接插入排序")]),s._v(" "),n("p",[n("strong",[s._v("1.算法思想")]),s._v("："),n("strong",[s._v("设待排序数据存放在数组 A[1..n]中，则 A[1]可看作是一个有序序列，让 i 从 2 开始，依次将 A[i]插入到有序序列 A[1..i-1]中， A[n]插入完毕则整个过程结束， A[1..n]成为有序序列")]),s._v("。")]),s._v(" "),n("p",[s._v("示例：[【2】,1,4,7,3,5,3]")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("[【1,2】,4,7,3,5,3]\n\n[【1,2,4】,7,3,5,3]\n\n[【1,2,4,7】,3,5,3]\n\n[【1,2,3,4,7】,5,3]\n\n[【1,2,3,4,5,7】,3]\n\n[【1,2,3,3,4,5,7】]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[n("strong",[s._v("2. 算法实现")]),s._v("：")]),s._v(" "),n("p",[s._v("在数组中增加元素 A[0]作为关键值存储器和循环控制开关。第 i 趟排序，即 A[i]的插入过程为：")]),s._v(" "),n("p",[s._v("① 保存 A[i]→A[0]")]),s._v(" "),n("p",[s._v("② j = i -1")]),s._v(" "),n("p",[s._v("③ 如果 A[j]<=A[0]（即待排序的 A[i]），则 A[0]→A[j+1]，完成插入；否则，将 A[j]后移一个位置：A[j]→A[j+1]； j = j - 1；继续执行 ③。")]),s._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[n("strong",[s._v("算法具有稳定性，时间复杂度 O(n²)")]),s._v("。")]),s._v(" "),n("h3",{attrs:{id:"希尔排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序"}},[s._v("#")]),s._v(" 希尔排序")]),s._v(" "),n("p",[s._v("1.算法思想：任取一个小于 n 的整数 S1 作为增量，把所有元素分成 S1个组。所有间距为 S1 的元素放在同一个组中。")]),s._v(" "),n("p",[s._v("第一组： {A[1]， A[S1+1]， A[2"),n("em",[s._v("S1+1]， ……}")])]),s._v(" "),n("p",[n("em",[s._v("第二组： {A[2]， A[S1+2]， A[2")]),s._v("S1+2]， ……}")]),s._v(" "),n("p",[s._v("第三组： {A[3]， A[S1+3]， A[2"),n("em",[s._v("S1+3]， ……}")])]),s._v(" "),n("p",[s._v("……")]),s._v(" "),n("p",[s._v("第 s1组： {A[S1]， A[2"),n("em",[s._v("S1]， A[3")]),s._v("S1]， ……}\n先在各组内进行直接插人排序；然后，取第二个增量 S2（<S1）重复上述的分组和排序，直至所取的增量 St=1\n（St<St-1<St-2<…<S2<S1），即所有记录放在同一组中进行直接插入排序为止")])])}),[],!1,null,null,null);a.default=v.exports}}]);