(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{456:function(t,s,a){"use strict";a.r(s);var e=a(20),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，MyBatis 3 中对缓存实现进行了许多改进。")]),t._v(" "),a("p",[t._v("默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：")]),t._v(" "),a("div",{staticClass:"language-xml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-xml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("cache")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),t._v(" "),a("p",[t._v("这个语句将会产生以下效果：")]),t._v(" "),a("ul",[a("li",[t._v("映射语句文件中的"),a("strong",[t._v("所有 select 语句的结果将会被缓存")]),t._v("。")]),t._v(" "),a("li",[t._v("映射语句文件中的"),a("strong",[t._v("所有 insert、update 和 delete 语句会刷新缓存")]),t._v("。")]),t._v(" "),a("li",[t._v("缓存会"),a("strong",[t._v("使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存")]),t._v("。")]),t._v(" "),a("li",[t._v("缓存"),a("strong",[t._v("不会定时")]),t._v("进行刷新（也就是说，没有刷新间隔）。")]),t._v(" "),a("li",[t._v("缓存会"),a("strong",[t._v("保存列表或对象")]),t._v("（无论查询方法返回哪种）的 1024 个引用。")]),t._v(" "),a("li",[t._v("缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。")])]),t._v(" "),a("p",[t._v("以上属性可以通过"),a("code",[t._v("cache")]),t._v("元素的属性修改：")]),t._v(" "),a("div",{staticClass:"language-xml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-xml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("cache")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("eviction")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("FIFO"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v("       \t"),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("\x3c!--")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("创建了一个")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("FIFO")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("缓存")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v('\n  flushInterval="50000"\t\t'),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 间隔 50000 ms = 50 s --\x3e")]),t._v('\n  size="1024"\t\t\t\t'),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 最多可以存储结果对象或列表的 1024 个引用 --\x3e")]),t._v('\n  readOnly="true"/>         '),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 返回的对象是只读的--\x3e")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("ol",[a("li",[a("p",[a("code",[t._v("eviction")]),t._v("（清除策略）可选：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("LRU")]),t._v(" (default)– 最近最少使用：移除最长时间不被使用的对象。")]),t._v(" "),a("li",[a("code",[t._v("FIFO")]),t._v(" – 先进先出：按对象进入缓存的顺序来移除它们。")]),t._v(" "),a("li",[a("code",[t._v("SOFT")]),t._v(" – 软引用：基于垃圾回收器状态和软引用规则移除对象。")]),t._v(" "),a("li",[a("code",[t._v("WEAK")]),t._v(" – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("flushInterval")]),t._v("（刷新间隔）属性可以被设置为"),a("strong",[t._v("任意的正整数")]),t._v("，设置的值应该是一个以"),a("strong",[t._v("毫秒为单位")]),t._v("的合理时间量。 "),a("strong",[t._v("默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("size")]),t._v("（引用数目）属性可以被设置为任意正整数，要"),a("strong",[t._v("注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("readOnly")]),t._v("（只读）属性可以被设置为 true 或 false。"),a("strong",[t._v("只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false")]),t._v("。")])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 "),a("code",[t._v("flushCache=true 的 insert/delete/update")]),t._v("语句时，缓存会获得更新。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);