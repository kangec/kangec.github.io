(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{479:function(t,a,s){"use strict";s.r(a);var _=s(20),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"java网络编程面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java网络编程面试题"}},[t._v("#")]),t._v(" "),s("strong",[t._v("JAVA网络编程面试题")])]),t._v(" "),s("h2",{attrs:{id:"_1、tcp和udp的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、tcp和udp的区别"}},[t._v("#")]),t._v(" 1、TCP和UDP的区别")]),t._v(" "),s("p",[s("strong",[t._v("TCP：是面向连接的流传输控制协议，具有高可靠性，确保传输数据的正确性，有验证重发机制，因此不会出现丢失或乱序。")])]),t._v(" "),s("p",[s("strong",[t._v("UDP：是无连接的数据报服务，不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序，但具有较好的实时性，UDP段结构比TCP的段结构简单，因此网络开销也小。")])]),t._v(" "),s("h2",{attrs:{id:"_2、tcp连接建立的时候3次握手，断开连接的4次握手的具体过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、tcp连接建立的时候3次握手，断开连接的4次握手的具体过程"}},[t._v("#")]),t._v(" 2、TCP连接建立的时候3次握手，断开连接的4次握手的具体过程")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("建立连接采用的3次握手协议，具体是指：")]),t._v(" "),s("ol",[s("li",[t._v("第一次握手是客户端connect连接到server。")]),t._v(" "),s("li",[t._v("第二次server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了。")]),t._v(" "),s("li",[t._v("第三次 就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。")])])])]),t._v(" "),s("p",[t._v("2．"),s("strong",[t._v("断开连接的4次握手,具体如下：")])]),t._v(" "),s("ol",[s("li",[t._v("断开连接的一端发送close请求是第一次握手")]),t._v(" "),s("li",[t._v("另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手")]),t._v(" "),s("li",[t._v("发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手")]),t._v(" "),s("li",[t._v("而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。")])]),t._v(" "),s("h2",{attrs:{id:"_3、什么是同步？什么是异步？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、什么是同步？什么是异步？"}},[t._v("#")]),t._v(" 3、什么是同步？什么是异步？")]),t._v(" "),s("p",[s("strong",[t._v("同步：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；")])]),t._v(" "),s("p",[s("strong",[t._v("异步：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。")])]),t._v(" "),s("h2",{attrs:{id:"_4、-什么是阻塞？什么是非阻塞？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、-什么是阻塞？什么是非阻塞？"}},[t._v("#")]),t._v(" 4、.什么是阻塞？什么是非阻塞？")]),t._v(" "),s("p",[s("strong",[t._v("阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；")])]),t._v(" "),s("p",[s("strong",[t._v("非阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。")])]),t._v(" "),s("h2",{attrs:{id:"_5、什么是阻塞io？什么是非阻塞io？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、什么是阻塞io？什么是非阻塞io？"}},[t._v("#")]),t._v(" 5、什么是阻塞IO？什么是非阻塞IO？")]),t._v(" "),s("p",[t._v("在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。通常来说，IO操作包括：")]),t._v(" "),s("p",[t._v("​\t对硬盘的读写、对socket的读写以及外设的读写。\n​\t\t\t当用户线程发起一个IO请求操作（本文以读请求操作为例），")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("1. 内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；\n2. 对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。\n3. 当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：\n  \t1. 查看数据是否就绪；\n  \t2. 进行数据拷贝（内核将数据拷贝到用户线程）。\n")])])]),s("p",[t._v("那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。")]),t._v(" "),s("p",[t._v("Java中传统的IO(BI/O)都是阻塞IO，比如通过socket来读数据，调用read()、accept()、write()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；")]),t._v(" "),s("p",[t._v("而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。")]),t._v(" "),s("h2",{attrs:{id:"_6、什么是同步io？什么是异步io？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、什么是同步io？什么是异步io？"}},[t._v("#")]),t._v(" "),s("strong",[t._v("6")]),t._v("、什么是同步IO？什么是异步IO？")]),t._v(" "),s("p",[t._v("我们先来看一下同步IO和异步IO的定义，在《Unix网络编程》一书中对同步IO和异步IO的定义是这样的：")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.")])])]),t._v(" "),s("p",[s("em",[s("strong",[t._v("An asynchronous I/O operation does not cause the requesting process to be blocked.")])])]),t._v(" "),s("p",[t._v("从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。")]),t._v(" "),s("p",[t._v("事实上，"),s("strong",[t._v("同步IO和异步IO模型是针对用户线程和内核的交互来说的：")])]),t._v(" "),s("p",[t._v("对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；")]),t._v(" "),s("p",[t._v("而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。")]),t._v(" "),s("p",[t._v("这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。")]),t._v(" "),s("p",[t._v("注意同步IO和异步IO与阻塞IO和非阻塞IO是不同的两组概念。")]),t._v(" "),s("p",[t._v("阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。")]),t._v(" "),s("h2",{attrs:{id:"_7、-io模型有几种？分别是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、-io模型有几种？分别是什么？"}},[t._v("#")]),t._v(" 7、 IO模型有几种？分别是什么？")]),t._v(" "),s("p",[t._v("在《Unix网络编程》一书中提到了五种IO模型")]),t._v(" "),s("p",[t._v("分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。")]),t._v(" "),s("p",[t._v("下面就分别来介绍一下这5种IO模型的异同。")]),t._v(" "),s("h3",{attrs:{id:"_1-阻塞io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-阻塞io模型"}},[t._v("#")]),t._v(" 1.阻塞IO模型")]),t._v(" "),s("p",[t._v("最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。")]),t._v(" "),s("p",[t._v("当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。")]),t._v(" "),s("p",[t._v("典型的阻塞IO模型的例子为：")]),t._v(" "),s("p",[s("code",[t._v("data = socket.openinputstream();")])]),t._v(" "),s("p",[t._v("如果数据没有就绪，就会一直阻塞在read方法。")]),t._v(" "),s("h3",{attrs:{id:"_2-非阻塞io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-非阻塞io模型"}},[t._v("#")]),t._v(" 2.非阻塞IO模型")]),t._v(" "),s("p",[t._v("当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。")]),t._v(" "),s("p",[t._v("所以事实上**，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU.**")]),t._v(" "),s("p",[t._v("典型的非阻塞IO模型一般如下：")]),t._v(" "),s("p",[s("strong",[t._v("伪代码")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("socket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" socket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     处理数据\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("但是对于非阻塞IO就有一个非常严重的问题，"),s("strong",[t._v("在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据.")])]),t._v(" "),s("h3",{attrs:{id:"_3-多路复用io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-多路复用io模型"}},[t._v("#")]),t._v(" 3.多路复用IO模型")]),t._v(" "),s("p",[s("strong",[t._v("多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。")])]),t._v(" "),s("p",[t._v("在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用.")]),t._v(" "),s("p",[t._v("在Java NIO中，是通过"),s("code",[t._v("selector.select()")]),t._v("去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。")]),t._v(" "),s("p",[t._v("也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。")]),t._v(" "),s("p",[t._v("而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。")]),t._v(" "),s("p",[t._v("另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。")]),t._v(" "),s("p",[t._v("不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询.")]),t._v(" "),s("h3",{attrs:{id:"_4-信号驱动io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-信号驱动io模型"}},[t._v("#")]),t._v(" 4.信号驱动IO模型")]),t._v(" "),s("p",[t._v("在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。")]),t._v(" "),s("h3",{attrs:{id:"_5-异步io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步io模型"}},[t._v("#")]),t._v(" 5.异步IO模型")]),t._v(" "),s("p",[t._v("异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。")]),t._v(" "),s("p",[t._v("而另一方面，从内核的角度，当它受到一个"),s("code",[t._v("asynchronous read")]),t._v("之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。")]),t._v(" "),s("p",[t._v("然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。")]),t._v(" "),s("p",[t._v("也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。")]),t._v(" "),s("p",[t._v("也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。")]),t._v(" "),s("p",[t._v("用户线程中不需要再次调用IO函数进行具体的读写。")]),t._v(" "),s("p",[t._v("这点是和信号驱动模型有所不同的")]),t._v(" "),s("p",[t._v("在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。")]),t._v(" "),s("p",[t._v("注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。也就是java中的AIO NIO2.0。")]),t._v(" "),s("p",[t._v("前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。")]),t._v(" "),s("h3",{attrs:{id:"_8、-reactor和proactor-io设计模式是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8、-reactor和proactor-io设计模式是什么？"}},[t._v("#")]),t._v(" 8、 Reactor和Proactor IO设计模式是什么？")]),t._v(" "),s("p",[t._v("在传统的网络服务设计模式中，有两种比较经典的模式：")]),t._v(" "),s("p",[t._v("​\t\t\t\t\t\t一种是 多线程，一种是线程池。")]),t._v(" "),s("p",[t._v("对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：")]),t._v(" "),s("div",{staticClass:"center-container"},[s("p",[s("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://i.loli.net/2020/07/24/ohLtNPlOW2jMrKJ.png",loading:"lazy"}})])]),s("p",[t._v("这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。")]),t._v(" "),s("p",[t._v("因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。")]),t._v(" "),s("p",[t._v("但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。")]),t._v(" "),s("p",[t._v("因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。")]),t._v(" "),s("p",[t._v("在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：")]),t._v(" "),s("div",{staticClass:"center-container"},[s("p",[s("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://i.loli.net/2020/07/24/YBhv5rIsCEAQf1z.png",loading:"lazy"}})])]),s("p",[t._v("多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。")]),t._v(" "),s("p",[t._v("在"),s("strong",[t._v("Proactor")]),t._v("模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是"),s("strong",[t._v("Proactor")]),t._v("模式。")]),t._v(" "),s("h2",{attrs:{id:"_9、java-nio-中的buffer是什么？如何使用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9、java-nio-中的buffer是什么？如何使用？"}},[t._v("#")]),t._v(" 9、Java NIO 中的Buffer是什么？如何使用？")]),t._v(" "),s("p",[t._v("Buffer(缓冲区):")]),t._v(" "),s("p",[t._v("Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；")]),t._v(" "),s("p",[t._v("Buffer本质上就是一块内存区；")]),t._v(" "),s("p",[t._v("一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。")]),t._v(" "),s("p",[t._v("Buffer的常见方法")]),t._v(" "),s("p",[s("code",[t._v("Buffer clear()")]),t._v(" "),s("code",[t._v("Buffer flip()")]),t._v(" "),s("code",[t._v("Buffer rewind()")]),t._v(" "),s("code",[t._v("Buffer position(int newPosition）")])])])}),[],!1,null,null,null);a.default=v.exports}}]);