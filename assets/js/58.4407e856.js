(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{465:function(v,_,t){"use strict";t.r(_);var s=t(20),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("TCP 是面向连接的协议。运输连接是用来传送TCP报文的。TCP连接运输的建立和释放是每一次面向连接的通讯中必不可少的过程。连接运输有三个阶段："),t("strong",[v._v("连接建立、数据传送、连接释放")]),v._v("。连接运输管理就是保证连接运输的建立和释放都能够正常的运行。")]),v._v(" "),t("p",[v._v("TCP连接运输需要解决以下几个问题：")]),v._v(" "),t("ul",[t("li",[v._v("要使每一方能够确知对方的存在。")]),v._v(" "),t("li",[v._v("允许双方协商一些参数（最大窗口值、是否使用窗口扩大选项、时间戳选项、服务质量）。")]),v._v(" "),t("li",[v._v("能够对运输实体资源（缓存大小、连接表中的项目）进行分配。")])]),v._v(" "),t("p",[v._v("TCP连接的建立采用客户端服务器的方式。主动发起连接建立的应用进程叫做"),t("strong",[v._v("客户端（Client）")]),v._v("，被动等待链接的应用进程叫做"),t("strong",[v._v("服务器（Server）")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"tcp连接的建立"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接的建立"}},[v._v("#")]),v._v(" TCP连接的建立")]),v._v(" "),t("p",[v._v('TCP建立连接的过程称为"握手"，握手需要在客户端和服务器之间交换三个TCP报文段。下图描述的是三报文握手建立TCP连接的过程。')]),v._v(" "),t("div",{staticClass:"center-container"},[t("p",[t("img",{staticClass:"lazy",attrs:{alt:"循环依赖","data-src":"/img/7/TCP.png",loading:"lazy"}})])]),t("p",[v._v("假设主机Ａ是运行TCP客户程序，主机B是运行服务端程序。最初两端都处于CLOSE状态。主机下方的方框表示TCP进程所处的状态。在示例中，"),t("strong",[v._v("A主动打开连接，B被动打开连接")]),v._v("。下面将介绍三次握手的详细过程。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("B的TCP服务器进程创建传输控制块TCB，准备接受客户端的连接请求。紧接着，服务器处于LISTEN状态，等待客户端的连接请求。")])]),v._v(" "),t("li",[t("p",[v._v("A的TCP客户端进程先创建传输控制块TCB。在建立TCP连接时，向B发出连接请求报文段，此时报文首部的同步位 "),t("code",[v._v("SYN=1")]),v._v(" ，并选择一个初始序号 "),t("code",[v._v("seq = x")]),v._v("。"),t("strong",[v._v("TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但要消耗一个序列号")]),v._v("。此时TCP客户端进程进入"),t("strong",[v._v("SYN-SENT（同步已发送）状态")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("B接收到请求报文段后，如同意建立连接，则向Ａ发送确认。在确认报文段中 "),t("code",[v._v("SYN = 1 ACK = 1")]),v._v(" ,确认号 "),t("code",[v._v("ack = x+1")]),v._v(",同时也要选择一个初始序号 "),t("code",[v._v("seq = y")]),v._v("。 "),t("strong",[v._v("TCP规定，确认报文段（SYN=1 ACK=1的报文段）不能携带数据，但要消耗一个序列号")]),v._v("。此时TCP服务的进程进入"),t("strong",[v._v("SYN-RCVD（同步已收到）状态")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("A收到B的确认后，还要向B发出确认。在确认报文段中 "),t("code",[v._v("ACK = 1")]),v._v(" ,确认号 "),t("code",[v._v("ack = y+1")]),v._v("，序列号 "),t("code",[v._v("seq = x+1")]),v._v("。"),t("strong",[v._v("TCP规定，ACK报文段可以携带数据。若不携带数据则不消耗序号")]),v._v("，在这种情况下，下一个数据报文段序号仍然是 "),t("code",[v._v("seq = x+1")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("至此，TCP连接已建立，A进入"),t("strong",[v._v("ESTABLISHED（已建立连接）状态")]),v._v("，当B收到A的确认后，也进入"),t("strong",[v._v("ESTABLISHED（已建立连接）状态")]),v._v("。")])])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),t("p",[v._v("传输控制块TCB：TCB存储了每一个连接中的一些重要信息，如：TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前发送和接收序号等。")])]),v._v(" "),t("p",[v._v("采用三报文握手的办法可以防止已失效的连接请求报文段突然又传送到服务器产生异常")]),v._v(" "),t("h2",{attrs:{id:"tcp连接的释放"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接的释放"}},[v._v("#")]),v._v(" TCP连接的释放")]),v._v(" "),t("p",[v._v("TCP连接释放过程较为繁杂，接下来我们仍结合双方状态改变来介绍连接释放过程。双方状态改变如下图：")]),v._v(" "),t("div",{staticClass:"center-container"},[t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"/img/7/TCPCLOSE.png",loading:"lazy"}})])]),t("p",[v._v("数据传输结束后，通信的双方都可以释放连接。现在A和B都处于ESTABLISHED状态。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("A的TCP客户端进程发出连接释放报文段，并停止发送数据，主动关闭TCP连接。连接释放报文段首部终止控制位"),t("code",[v._v("FIN = 1")]),v._v(",序号 "),t("code",[v._v("seq = u")]),v._v(","),t("strong",[v._v("u等于已传送的数据的最后一个字节的序号加1")]),v._v("。此时，A进入"),t("strong",[v._v("FIN-WAIT-1（终止等待1）状态")]),v._v("，等待B的确认。"),t("strong",[v._v("TCP规定，FIN报文段即使不携带数据，但要消耗一个序列号")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("B收到连接释放报文段后即发出确认，确认号 "),t("code",[v._v("ack = u+1")]),v._v(",序号"),t("code",[v._v("seq = v")]),v._v(","),t("strong",[v._v("v等于已传送的数据的最后一个字节的序号加1")]),v._v("。此时，B进入"),t("strong",[v._v("CLOSE-WAIT（关闭等待）状态")]),v._v("。TCP服务器进程将通知高层应用进程TCP连接将要被释放，此时的TCP连接处于半关闭状态，等待B发送数据完成。")])]),v._v(" "),t("li",[t("p",[v._v("A收到来自B的确认后，进入"),t("strong",[v._v("FIN-WAIT-2（终止等待2）状态")]),v._v("，等待B发出的连接释放报文段。")])]),v._v(" "),t("li",[t("p",[v._v("若B已经完成数据发送，其应用进程将通知TCP释放连接。此时B发送的连接释放报文段首部终止控制位"),t("code",[v._v("FIN = 1")]),v._v(",序号 "),t("code",[v._v("seq = w")]),v._v("，"),t("strong",[v._v("w等于已传送的数据的最后一个字节的序号加1")]),v._v("。B还必须重复已发送过的确认号 "),t("code",[v._v("ack = u + 1")]),v._v("。这时B就进入"),t("strong",[v._v("LAST-ACK(最后确认)状态")]),v._v("，等待A的确认。")])]),v._v(" "),t("li",[t("p",[v._v("A收到来自B的连接释放报文段后，向B发送确认报文段。在确认报文段中 "),t("code",[v._v("ACK = 1")]),v._v(" ,确认号 "),t("code",[v._v("ack = w + 1")]),v._v("，序列号 "),t("code",[v._v("seq = u+1")]),v._v("(根据TCP标准，FIN报文段消耗掉了序号u)。接着A进入"),t("strong",[v._v("TIME-WAIT(时间等待)状态")]),v._v("。此时的"),t("strong",[v._v("TCP连接还未释放")]),v._v("，必须等待"),t("strong",[v._v("时间等待计时器（TIME-WAIT timer）设置的时间2MSL后，A才进入到CLOSE状态")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("从A进入TIME-WAIT状态后，经过四分钟进入到CLOSE状态，此时才能开始建立下一个新的连接。当Ａ撤销相应的传输控制块TCB后，TCP连接才真正的结束。")])])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),t("p",[v._v("时间MSL称为"),t("strong",[v._v("最长报文段寿命")]),v._v("，RCF793建议设置为2分钟。MSL可根据具体情况使用自定义值。")])]),v._v(" "),t("h2",{attrs:{id:"tcp的有限状态机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp的有限状态机"}},[v._v("#")]),v._v(" TCP的有限状态机")]),v._v(" "),t("p",[v._v("TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。")]),v._v(" "),t("p",[v._v("图中有三种不同的箭头。")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("粗实线箭头表示对客户进程的正常变迁。")])]),v._v(" "),t("li",[t("p",[v._v("粗虚线箭头表示对服务器进程的正常变迁。")])]),v._v(" "),t("li",[t("p",[v._v("另一种细线箭头表示异常变迁。")])])]),v._v(" "),t("div",{staticClass:"center-container"},[t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://i.loli.net/2020/09/01/23njiT9bxGucNpE.png",loading:"lazy"}})])])])}),[],!1,null,null,null);_.default=a.exports}}]);