---
title: Java网络编程面试题(三)
sidebar: auto
categories: 
  - 面试题
  - Java面试题
tags: 
  - 面试题
date: 2020-07-24 09:43:33
permalink: /pages/1e323d/
---

## 14、select、poll和epoll的区别

在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。

**select****的缺点：**

1. 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；

   ```c
   //在linux内核头文件中，有这样的定义：
   #define __FD_SETSIZE  1024
   ```

2. 内核 / 用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销；

3.  select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；

4. select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。

相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。 

拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。

除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。

因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。

 **epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。**

设想一下如下场景：

有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？

 在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。

 epoll的设计和实现与select完全不同。

epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)把原先的select/poll调用分成了3个部分：

​	1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)

​	2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字

​	3）调用epoll_wait收集发生的事件的连接

 如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。

 下面来看看Linux内核具体的epoll机制实现思路。

 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：

```c
struct eventpoll{  

....  

/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/  

struct rb_root rbr; 

/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/  

struct list_head rdlist; 

 ....

};
```



每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。

而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。

在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：

```c
struct epitem{  

struct rb_node rbn;//红黑树节点  

struct list_head  rdllink;//双向链表节点   

struct epoll_filefd ffd; //事件句柄信息  

struct eventpoll *ep;  //指向其所属的eventpoll对象  

struct epoll_event event; //期待发生的事件类型

}
```

当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。
::: center
![](https://i.loli.net/2020/07/24/R9UAQpwS5ElCbiZ.png)
:::

**epoll的用法**

第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。

第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。

第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。

## 15、网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？

1. 进程：
   1. 子进程是父进程的复制品。
   2. 子进程获得父进程数据空间、堆和栈的复制品。
2. 线程：

相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
 两者都可以提高程序的并发度，提高程序运行效率和响应时间。 线程和进程在使用上各有优缺点：

线程执行开销小，但不利于资源管理和保护；而进程正相反。

同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

SMP的全称是"对称多处理"（Symmetrical Multi-Processing）技术，是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。

## 16、网络编程的一般步骤

### 对于TCP连接

**1.服务器端**

```java
1）创建套接字create；

2）绑定端口号bind；

3）监听连接listen；

4）接受连接请求accept，并返回新的套接字；

5）用新返回的套接字recv/send；

6）关闭套接字。
```

**2.客户端**

```java
1）创建套接字create;

2）发起建立连接请求connect; 

3）发送/接收数据send/recv；

4）关闭套接字。
```

**TCP总结：**

​	**Server端：create – bind – listen–  accept–  recv/send– close**

​	**Client端：create——- conncet——send/recv——close.**

###  对于UDP连接

**1.服务器端:**

```java
1）创建套接字create；

2）绑定端口号bind；

3）接收/发送消息recvfrom/sendto；

4）关闭套接字。
```

**2.客户端:**

```java
1）创建套接字create；

2）发送/接收消息sendto/recvfrom；

3）关闭套接字.
```

**UDP总结:**

​	**Server端：create—-bind —-recvfrom/sendto—-close**

​	**Client端：create—-  sendto/recvfrom—-close.**

**函数原型int recv( _In_ SOCKET s, _Out_ char *buf, _In_ int len, _In_ int flags);**

##  17、TCP为什么不是两次连接？而是三次握手？

如果A与B两个进程通信，如果仅是两次连接。**可能出现的一种情况**就是：

A发送完请求报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。

B收到报文后，会向A发起连接。此时两次握手完毕

B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求

而A对失效的报文回复自然不会处理。

因此会陷入B忙等的僵局，造成资源的浪费。