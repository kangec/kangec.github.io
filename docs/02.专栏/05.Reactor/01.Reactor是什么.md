---
title: Reactor是什么
date: 2020-09-08 19:04:28
permalink: /pages/0454ff/
categories: 
  - 专栏
  - Reactor
tags: 
  - 
---
## Reactor简介

Reactor是JVM的完全非阻塞式反应式编程基础，具有高效的需求管理（以管理“背压”的形式）。 它直接与Java 8功能API集成在一起，特别是CompletableFuture，Stream和Duration。 它提供了可组合的异步序列API，例如Flux（用于[N]个元素）和Mono（用于[0 | 1]个元素），并且广泛实现了Reactive Streams规范。

Reactor还支持与Reactor-Netty项目的非阻塞进程间通信。 适用于微服务架构，Reactor Netty为HTTP（包括Websockets），TCP和UDP提供了支持背压的网络引擎。,并且完全支持反应式编码和解码。

<!-- more -->

## 先决条件

**Reactor Core在Java 8及更高版本上运行**。

它对`org.reactivestreams：reactive-streams：1.0.3`具有传递依赖。

::: tip
Android支持: 
- Reactor 3并未正式支持Android或将其定位为Android（如果强烈要求使用RxJava 2，请考虑使用RxJava 2）。但是，它在Android SDK 26（Android O）及更高版本上应该可以正常工作。

- 启用反欺骗功能后，它可能会在Android SDK 21（Android 5.0）及更高版本上正常工作。 参见https://developer.android.com/studio/write/java8-support#library-desugaring

:::

## 反应式编程简介

Reactor是反应式编程范例的实现，可以总结如下：

> 反应式编程是一种异步编程范式，它涉及数据流和变化的传播。这意味着可以通过所采用的编程语言轻松表达静态（例如数组）或动态（例如事件发射器）数据流。

— https://en.wikipedia.org/wiki/Reactive_programming

作为响应式编程方向的第一步，Microsoft在.NET生态系统中创建了响应式扩展（Rx）库。然后RxJava在JVM上实现了反应式编程。随着时间的流逝，通过Reactive Streams的努力，出现了Java的标准化，该规范定义了JVM上的响应库的一组接口和交互规则。它的接口已集成到`Flow`该类下的Java 9中。

反应式编程范例通常以面向对象的语言表示，作为**Observer设计模式**的扩展。您还可	以将主要的反应流模式与熟悉的Iterator设计模式进行比较，因为所有这些库中的`Iterable`- `Iterator`对都有双重性 。一个主要的区别是，虽然**Iterator是基于pull**的，但**反应式流是基于push**的。

使用迭代器是命令式编程模式，即使访问值的方法仅由负责`Iterable`。实际上，由开发人员决定何时选择`next()`序列中的项目。在反应性物流中，上述对的等价物为`Publisher-Subscriber`。但是，当 `Publisher`新可用值*出现时*，正是通知订户，而这一推送方面是做出反应的关键。同样，应用于推入值的操作以声明方式而不是命令方式表示：程序员表示计算的逻辑，而不是描述其确切的控制流程。

除了推送值之外，还以明确定义的方式涵盖了错误处理和完成方面。A `Publisher`可以`Subscriber`（通过调用`onNext`）将新值推入其值，但也可以通过（调用`onError`）或完成（通过调用`onComplete`）发出错误信号。错误和完成都会终止序列。可以总结如下：

```java
onNext x 0..N [onError | onComplete]
```

这种方法非常灵活。该模式支持没有值，一个值或n个值（包括无限个值序列，例如时钟的连续滴答声）用例。

## 从命令式编程到反应式编程

反应性库（例如Reactor）旨在解决JVM上“经典”异步方法的这些缺点，同时还着重于一些其他方面：

- 可组合性和可读性
- 以丰富的运算符词汇操纵数据流
- 订阅之前没有任何反应
- 背压或消费者向生产者发出排放速率过高信号的能力
- 并发不可知的高级但高价值的抽象
