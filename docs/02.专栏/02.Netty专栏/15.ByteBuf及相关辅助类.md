---
title: ByteBuf及相关辅助类
date: 2020-09-20 10:39:07
permalink: /pages/b211b5/
categories: 
  - 专栏
  - Netty专栏
tags: 
  - Netty
---
## ByteBuf功能介绍
从功能角度而言，ByteBuffer完全可以满足NIO编程的需要，但是由于NIO编程的复杂性， ByteBuffer也有其局限性，它的主要缺点如下。

1. ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常;
2. ByteBuffer只有一个标识位置的指针 position，读写的时候需要手工调用flip()和rewind()等，使用者必须小心谨慎地处理这些API，否则很容易导致程序处理失败
3. ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己
编程实现

为了弥补这些不足，Nety提供了自己的 ByteBuffer 实现-ByteBuf。

<!-- more -->

### 1.1 工作原理

ByteBuf通过两个位置指针来协助缓冲区的读写操作，读操作使用 readerIndex，写操作使用 writerIndex。

```
 *      +-------------------+------------------+------------------+
 *      | discardable bytes |  readable bytes  |  writable bytes  |
 *      |                   |     (CONTENT)    |                  |
 *      +-------------------+------------------+------------------+
 *      |                   |                  |                  |
 *      0      <=      readerIndex   <=   writerIndex    <=    capacity
```

readerIndex和 writerIndex的取值一开始都是**0**,随着数据的写入 writerIndex 会增加，读取数据会使 readerlndex 增加，但是它不会超过 writerlndex。

在读取之后，**(0 ~ readerlndex)**就被视为 discard 的，调用 discarDreadBytes 方法，可以释放这部分空间，它的作用类似ByteBuffer的compact方法。 **(readerIndex ~ writerIndex)**之间的数据是可读取的，等价于ByteBuffer position 和 limit 之间的数据。 **(writerIndex ~ capacity)**之间的空间是可写的，等价于 ByteBuffer limit和 capacity之间的可用空间。

```
*  BEFORE discardReadBytes()
*
*      +-------------------+------------------+------------------+
*      | discardable bytes |  readable bytes  |  writable bytes  |
*      +-------------------+------------------+------------------+
*      |                   |                  |                  |
*      0      <=      readerIndex   <=   writerIndex    <=    capacity
*
*
*  AFTER discardReadBytes()
*
*      +------------------+--------------------------------------+
*      |  readable bytes  |    writable bytes (got more space)   |
*      +------------------+--------------------------------------+
*      |                  |                                      |
* readerIndex (0) <= writerIndex (decreased)        <=        capacity
```

由于写操作不修改 readerIndex指针，读操作不修改 writerIndex指针，因此读写之间不再需要调整位置指针，这极大地简化了缓冲区的读写操作，避免了由于遗漏或者不熟悉flip()操作导致的功能异常。

```
*  BEFORE clear()
*
*      +-------------------+------------------+------------------+
*      | discardable bytes |  readable bytes  |  writable bytes  |
*      +-------------------+------------------+------------------+
*      |                   |                  |                  |
*      0      <=      readerIndex   <=   writerIndex    <=    capacity
*
*  AFTER clear()
*
*      +---------------------------------------------------------+
*      |             writable bytes (got more space)             |
*      +---------------------------------------------------------+
*      |                                                         |
*      0 = readerIndex = writerIndex            <=            capacity
```

### 1.2 ByteBuf动态扩展

通常情况下，对 ByteBuffer 进行put操作时，如果缓冲区剩余可写空间不够，就会发生 BufferOverflowException。为了避免发生这个问题，通常在进行put操作的时候会对剩余可用空间进行校验。如果剩余空间不足，需要重新创建一个新的 ByteBuffer，并将之前的 ByteBuffer 复制到新创建的 ByteBuffer中，最后释放老的 ByteBuffer。对此，为了防止 ByteBuffer 溢出，都会对可用空间进行校验，导致了代码冗余，而且可能引入其他问题。

为了解决这个问题，ByteBuf 对 write 操作进行了封装，由 ByteBuf 的 write 操作负责进行剩余可用空间的校验，如果可用缓冲区不足，ByteBuf会自动进行动态扩展，对于使用者而言，不需要关心底层的校验和扩展细节，只要不超过设置的最大缓冲区容量即可。当可用空间不足时，
ByteBuf会帮助我们实现自动扩展，这极大地降低了 ByteBuf 的学习和使用成本，提升了开发效率。校验和扩展的相关代码：

```java
@Override
public ByteBuf writeByte(int value) {
    ensureWritable0(1);
    _setByte(writerIndex++, value);
    return this;
}
```
当进行 write 操作时会对需要 write 的字节进行校验，如果可写的字节数小于需要写入的字节数，并且需要写入的字节数小于可写的最大字节数时，对缓冲区进行动态扩展。

由于NIO的Channel读写的参数都是 ByteBuffer 因此，Nety的 ByteBuf 接口必须提供API方便的将 Bytebuf 转换成 ByteBuffer，或者将 ByteBuffer包装成 ByteBuf。考虑到性能，应该尽量避免缓冲区的复制，内部实现的时候可以考虑聚合一个 ByteBuffer 的私有指针用来代表 ByteBuffer.

```java
final void ensureWritable0(int minWritableBytes) {
    ensureAccessible();
    if (minWritableBytes <= writableBytes()) {
        return;
    }
    final int writerIndex = writerIndex();
    if (checkBounds) {
        if (minWritableBytes > maxCapacity - writerIndex) {
            throw new IndexOutOfBoundsException(String.format(
                    "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s",
                    writerIndex, minWritableBytes, maxCapacity, this));
        }
    }

    // Normalize the current capacity to the power of 2.
    int minNewCapacity = writerIndex + minWritableBytes;
    int newCapacity = alloc().calculateNewCapacity(minNewCapacity, maxCapacity);

    int fastCapacity = writerIndex + maxFastWritableBytes();
    // Grow by a smaller amount if it will avoid reallocation
    if (newCapacity > fastCapacity && minNewCapacity <= fastCapacity) {
        newCapacity = fastCapacity;
    }

    // Adjust to the new capacity.
    capacity(newCapacity);
}

protected final void ensureAccessible() {
    if (checkAccessible && !isAccessible()) {
        throw new IllegalReferenceCountException(0);
    }
}
```

## ByteBuf源码分析

### 2.1 ByteBuf主要继承关系

![](https://i.loli.net/2020/09/20/Mf7kNOeURwTzt1x.png)

从内存分配的角度看， ByteBuf可以分为两类：

1. 堆内存（ HeapByteBuf）字节缓冲区：特点是内存的分配和回收速度快，可以被JVM自动回收；缺点就是如果进行 Socket的IO读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核 Channel中，性能会有一定程度的下降。
2. 直接内存（ DirectByteBuf）字节缓冲区：非堆内存，它在堆外进行内存分配，相比于堆内存，它的分配和回收速度会慢一些，但是将它写入或者从 Socket Channel中读取时，由于少了一次内存复制，速度比堆内存快。

正是因为各有利弊，所以Nety提供了多种 ByteBuf供开发者使用，经验表明， ByteBuf的最佳实践是**在IO通信线程的读写缓冲区使用 DirectByteBuf**，**后端业务消息的编解码模块使用 HeapByteBuf。这样组合可以达到性能最优**。

从内存回收角度看， ByteBuf也分为两类：基于对象池的 ByteBuf和普通 ByteBuf。两者的主要区别就是**基于对象池的 ByteBuf 可以重用 ByteBuf 对象**，它自己维护了一个内存池，可以循环利用创建的 ByteBuf，提升内存的使用效率，降低由于高负载导致的频繁GC测试表明使用内存池后的Nety在高负载、大并发的冲击下内存和GC更加平稳。

尽管推荐使用基于内存池的 ByteBuf，但是内存池的管理和维护更加复杂，使用起来也需要更加谨慎。因此，Nety提供了灵活的策略供使用者来做选择。

## ByteBuf辅助类