---
title: 聊聊MyBatis缓存机制 —— 入门
date: 2020-09-03 21:38:44
permalink: /pages/87c9c3/
categories: 
  - 专栏
  - MyBatis专栏
tags: 
  - MyBatis
---
MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，MyBatis 3 中对缓存实现进行了许多改进。

默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：

```xml
<cache/>
```

<!-- more -->

这个语句将会产生以下效果：

- 映射语句文件中的**所有 select 语句的结果将会被缓存**。
- 映射语句文件中的**所有 insert、update 和 delete 语句会刷新缓存**。
- 缓存会**使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存**。
- 缓存**不会定时**进行刷新（也就是说，没有刷新间隔）。
- 缓存会**保存列表或对象**（无论查询方法返回哪种）的 1024 个引用。
- 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。

::: tip

缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。

:::

以上属性可以通过`cache`元素的属性修改：

```xml
<cache
  eviction="FIFO"       	<!-- 创建了一个 FIFO 缓存 -->
  flushInterval="50000"		<!-- 间隔 50000 ms = 50 s -->
  size="1024"				<!-- 最多可以存储结果对象或列表的 1024 个引用 -->
  readOnly="true"/>         <!-- 返回的对象是只读的-->
```

1. `eviction`（清除策略）可选：

    - `LRU` (default)– 最近最少使用：移除最长时间不被使用的对象。
    - `FIFO` – 先进先出：按对象进入缓存的顺序来移除它们。
    - `SOFT` – 软引用：基于垃圾回收器状态和软引用规则移除对象。
    - `WEAK` – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。

2. `flushInterval`（刷新间隔）属性可以被设置为**任意的正整数**，设置的值应该是一个以**毫秒为单位**的合理时间量。 **默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新**。

3. `size`（引用数目）属性可以被设置为任意正整数，要**注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024**。

4. `readOnly`（只读）属性可以被设置为 true 或 false。**只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false**。

::: tip

二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 `flushCache=true 的 insert/delete/update `语句时，缓存会获得更新。

:::