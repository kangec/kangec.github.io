---
title: JVM垃圾回收算法
date: 2020-09-10 21:44:41
permalink: /pages/d1b4c7/
categories: 
  - 专栏
  - Java基础
tags: 
  - 
---
垃圾回收算法涉及大量的细节且各平台实现机制不同，本文只是简单介绍算法的思想。

<!-- more -->

## 标记-清除（Mark-Sweep）

**标记—清除算法是最基础的收集算法**，它分为“**标记**”和“**清除**”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，**标记过程即为可达性分析算法中判定垃圾对象的标记过程**。标记-清除算法执行过程：

![image-20200910215618978](https://i.loli.net/2020/09/10/HKyoiLqGIuv1E87.png)

该算法有如下缺点：

- 标记和清除过程的**效率都不高**
- 标记清除后会产生大量不连续的**内存碎片**，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作

## 复制（Copying）

复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它将可用内存按容量分为大小相等的两块，每次只使用其中的一块，**当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉**。复制算法有如下优点：

- 每次只对一块内存进行回收，运行高效；
- 只需移动栈顶指针，按顺序分配内存即可，实现简单；
- 内存回收时不用考虑内存碎片的出现；

它的缺点是：可一次性分配的**最大内存缩小了一半**。 复制算法执行过程：

![image-20200910220002354](https://i.loli.net/2020/09/10/zZqAPO3fQgwRVYy.png)

现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为**一块比较大的Eden空间和两块较小的Survivor空间**，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是**8:1**，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。

当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于**老年代**进行**分配担保**，所以大对象直接进入老年代。

## 标记-整理（Mark-Compact）

复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，**而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存**。标记—整理算法的回收情况如下所示：

![image-20200910220216859](https://i.loli.net/2020/09/10/hHkUx9vSLNwf8Wg.png)

## 分代收集（Generational Collection）

当前商业虚拟机的垃圾收集都采用分代收集，它**根据对象的存活周期的不同将内存划分为几块**，一般是把Java堆分为**新生代**和**老年代**。

- 在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用**复制算法**来完成收集
- 老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记—清除算法**或**标记—整理算法**来进行回收

## 总结

| GC算法   | 优点           | 缺点               | 存活对象移动 | 内存碎片 | 适用场景 |
| -------- | -------------- | ------------------ | ------------ | -------- | -------- |
| 引用计数 | 实现简单       | 不能处理循环引用   |              |          |          |
| 标记清除 | 不需要额外空间 | 两次扫描，耗时严重 | N            | Y        | 老年代   |
| 复制     | 没有标记和清除 | 需要额外空间       | Y            | N        | 新生代   |
| 标记整理 | 没有内存碎片   | 需要移动对象的成本 | Y            | N        | 老年代   |

> 参考资料： 《深入了解Java虚拟机》