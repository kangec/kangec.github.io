---
title: 聊聊Java多态
date: 2020-10-21 15:43:55
permalink: /pages/1b5baf/
categories: 
  - 专栏
  - Java基础
tags: 
  - 
---
## 简介

多态是面向对象编程语言中，继数据抽象(封装)和继承之外的第三个重要特性。

**多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做**。多态不仅能改善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项目时还是在添加新特性时都可以“生长”的程序。

**封装通过合并特征和行为来创建新的数据类型**。**隐藏实现通过将细节私有化把接口与实现分离**。这种类型的组织机制对于有面向过程编程背景的人来说，更容易理解。而**多态是消除类型之间的耦合**。继承允许把一个对象视为它本身的类型或它的基类类型。这样就能把很多派生自一个基类的类型当作同一类型处理，因而一段代码就可以无差别地运行在所有不同的类型上了。**多态方法调用允许一种类型表现出与相似类型的区别，只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由具体方法的不同行为表现出来的**。

<!-- more -->

## 方法调用绑定

将一个方法调用和一个方法主体关联起来称作**绑定**。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做***前期绑定**。它是面向过程语言默认的绑定方式，例如在 C 语言中就只有*前期绑定*这一种方法调用。在前期绑定中，编译器只知道一个 **Instrument** 引用，它无法得知究竟会调用哪个方法。

解决方法就是**后期绑定**，意味着**在运行时根据对象的类型进行绑定**。**后期绑定也称为*动态绑定*或*运行时绑定***。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息。

Java 中除了 **static** 和 **final** 方法（**private** 方法也是隐式的 **final**）外，**其他所有方法都是后期绑定**。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。

::: tip

为什么将一个对象指明为 **final** ？它可以防止方法被重写。但更重要的一点可能是，**它有效地”关闭了“动态绑定**，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 **final** 方法生成更**高效**的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 **final**，而不是为了提升性能而使用。

:::

### 误区一：重写'private'方法

**private** 方法可以当作是 **final** 的，对于派生类来说是隐蔽的。因此子类中的方法是一个全新的方法；因为基类版本的屏蔽了**private**它都不算是重写方法。

只有非 **private** 方法才能被重写，但是得小心重写 **private** 方法的现象，编译器不报错，但不会按我们所预期的执行。为了清晰起见，派生类中的方法名采用与基类中 **private** 方法名不同的命名。

### 误区二：属性和静态方法

**只有普通的方法调用可以是多态的，调用属性不具备多态性。**

```java
class Super {
    public int field = 0;

    public int getField() {
        return field;
    }
}

class Sub extends Super {
    public int field = 1;

    @Override
    public int getField() {
        return field;
    }

    public int getSuperField() {
        return super.field;
    }
}

public class FieldAccess {
    public static void main(String[] args) {
        Super sup = new Sub(); // Upcast
        System.out.println("sup.field = " + sup.field + 
                          ", sup.getField() = " + sup.getField());
        Sub sub = new Sub();
        System.out.println("sub.field = " + sub.field + 
                          ", sub.getField() = " + sub.getField()
                          + ", sub.getSuperField() = " + sub.getSuperField())
    }
}

```

```tex
sup.field = 0, sup.getField() = 1
sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0
```

**如果一个方法是静态(static)的，它的行为就不具有多态性**

## 构造器和多态

通常，构造器不同于其他类型的方法。在涉及多态时也是如此。尽管**构造器不具有多态性**（事实上人们会把它看作是隐式声明的静态方法），但是理解构造器在复杂层次结构中运作多态还是非常重要的。理解这个可以帮助你避免一些不愉快的困扰。

###  构造器调用顺序

在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此**每个基类的构造器都会被调用到**。这么做是有意义的，因为**构造器有着特殊的任务：检查对象是否被正确地构造**。由于属性通常声明为 **private**，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。这就是为什么编译器会强制调用每个派生类中的构造器的原因。**如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器**。如果没有无参构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。

对象的构造器调用顺序如下：

1. 基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类。
2. 按声明顺序初始化成员。
3. 调用派生类构造器的方法体。

构造器的调用顺序很重要。当使用继承时，就已经知道了基类的一切，并可以访问基类中任意 **public** 和 **protected** 的成员。这意味着在派生类中可以假定所有的基类成员都是有效的。在一个标准方法中，构造动作已经发生过，对象其他部分的所有成员都已经创建好。

### 构造器内部多态方法的行为

构造器调用的层次结构带来了一个困境。如果在构造器中调用了正在构造的对象的动态绑定方法，会发生什么呢？

在普通的方法中，动态绑定的调用是在运行时解析的，因为对象不知道它属于方法所在的类还是类的派生类。

**如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义**。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些 bug 很隐蔽，难以发现。

从概念上讲，构造器的工作就是创建对象（这并非是平常的工作）。在构造器内部，整个对象可能只是部分形成——只知道基类对象已经初始化。如果构造器只是构造对象过程中的一个步骤，且构造的对象所属的类是从构造器所属的类派生出的，那么派生部分在当前构造器被调用时还没有初始化。然而，一个动态绑定的方法调用向外深入到继承层次结构中，它可以调用派生类的方法。如果你在构造器中这么做，就可能调用一个方法，该方法操纵的成员可能还没有初始化——这肯定会带来灾难。

上述的构造器初始化的实际过程是：

1. 在所有事发生前，分配给对象的存储空间会被初始化为二进制 0。
2. 如前所述调用基类构造器。
3. 按声明顺序初始化成员。
4. 最终调用派生类的构造器。

## 协变返回类型

Java 5 中引入了协变返回类型，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型：

```java
class Grain {
    @Override
    public String toString() {
        return "Grain";
    }
}

class Wheat extends Grain {
    @Override
    public String toString() {
        return "Wheat";
    }
}

class Mill {
    Grain process() {
        return new Grain();
    }
}

class WheatMill extends Mill {
    @Override
    Wheat process() {
        return new Wheat();
    }
}
```

